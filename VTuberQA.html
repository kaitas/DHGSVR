<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VTuber ä¸€å•ä¸€ç­” è‡ªå·±ç´¹ä»‹ Maker (HTML only)</title>
  <style>
    :root {
      color-scheme: light dark;
    }

    body {
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans JP", sans-serif;
      margin: 16px;
      background: #888888;
      /* è¿½åŠ ï¼šæ“ä½œç”»é¢ã‚’ç™½ */
      color: #000000;
      /* è¿½åŠ ï¼šæ–‡å­—ãŒè–„ããªã‚‹ã®é˜²æ­¢ */
    }

    h1 {
      margin: 0 0 10px;
      font-size: 20px;
    }

    .row {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      align-items: flex-start;
    }

    .card {
      border: 1px solid rgba(127, 127, 127, .35);
      border-radius: 12px;
      padding: 12px;
      background: rgba(0, 0, 0, .03);
      /* å°‘ã—ã ã‘è–„ã„ã‚°ãƒ¬ãƒ¼ */
    }

    .card h2 {
      font-size: 14px;
      margin: 0 0 10px;
      opacity: .9;
    }

    label {
      display: block;
      font-size: 12px;
      opacity: .9;
      margin-top: 8px;
    }

    input[type="text"],
    input[type="number"],
    select,
    textarea {
      width: 100%;
      box-sizing: border-box;
      padding: 8px;
      border: 1px solid rgba(127, 127, 127, .35);
      border-radius: 10px;
      background: transparent;
    }

    textarea {
      min-height: 70px;
    }

    button {
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(127, 127, 127, .35);
      background: rgba(127, 127, 127, .12);
      cursor: pointer;
      font-weight: 600;
    }

    button:disabled {
      opacity: .5;
      cursor: not-allowed;
    }

    .small {
      font-size: 12px;
      opacity: .85;
    }

    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 12px;
    }

    th,
    td {
      border-bottom: 1px solid rgba(127, 127, 127, .2);
      padding: 6px;
      vertical-align: top;
    }

    th {
      text-align: left;
      opacity: .9;
    }

    .controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .pill {
      display: inline-block;
      padding: 3px 8px;
      border: 1px solid rgba(127, 127, 127, .35);
      border-radius: 999px;
      font-size: 12px;
      opacity: .9;
    }

    canvas {
      width: 100%;
      max-width: 720px;
      border-radius: 12px;
      border: 1px solid rgba(127, 127, 127, .35);
      background: #00ff00;
      /* å¤‰æ›´ï¼šãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ç”»é¢ã®èƒŒæ™¯ï¼ˆè¡¨ç¤ºï¼‰ã‚’ç·‘ */
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
  </style>
</head>

<body>
  <h1>VTuber ä¸€å•ä¸€ç­” è‡ªå·±ç´¹ä»‹ Makerï¼ˆHTMLã®ã¿ / å­—å¹•ç„¼ãè¾¼ã¿å‹•ç”»ç”Ÿæˆï¼‰</h1>
  <p class="small">
    ä½¿ã„æ–¹ï¼šBGMã‚’é¸ã¶ â†’ å›ç­”ã‚’æ›¸ã â†’ï¼ˆå‰å¥ã‚ªãƒ•ã‚»ãƒƒãƒˆ&æ‹å€ç‡ã§åˆã‚ã›ã‚‹ï¼‰â†’ã€Œå‹•ç”»ç”Ÿæˆã€ã€‚
    <span class="pill">æ¨å¥¨: Chrome / Edge</span>
  </p>

  <div class="row">
    <div class="card" style="flex: 1 1 360px; min-width: 320px;">
      <h2>ç´ æ</h2>
      <label>BGMï¼ˆmp3/wavï¼‰</label>
      <input id="audioFile" type="file" accept="audio/*" />
      <label>èƒŒæ™¯ç”»åƒï¼ˆä»»æ„ / png,jpgï¼‰</label>
      <input id="bgFile" type="file" accept="image/*" />
      <label>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼</label>
      <audio id="audioEl" controls style="width:100%"></audio>
      <div class="small">â€»BGMã¯ã‚ãªãŸãŒæ¨©åˆ©çš„ã«åˆ©ç”¨ã§ãã‚‹éŸ³æºã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„ã€‚</div>
    </div>

    <div class="card" style="flex: 1 1 520px; min-width: 320px;">
      <h2>å‹•ç”»è¨­å®š</h2>
      <div class="grid">
        <div>
          <label>BPM</label>
          <input id="bpm" type="number" value="126" min="30" max="300" />
        </div>

        <div>
          <label>å‰å¥ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆæ‹ï¼‰</label>
          <input id="introOffsetBeats" type="number" value="0" min="-128" max="512" step="1" />
          <div class="small">ä¾‹ï¼šå‰å¥ã§å­—å¹•ã‚’é…ã‚‰ã›ãŸã„â†’ +8 ãªã©</div>
        </div>

        <div>
          <label>æ‹ã®å€ç‡ï¼ˆãƒ™ãƒ¼ã‚¹æ‹åˆã‚ã›ï¼‰</label>
          <select id="beatMultiplier">
            <option value="1">1.0ï¼ˆå››åˆ†éŸ³ç¬¦1æ‹ï¼‰</option>
            <option value="0.5" selected>0.5ï¼ˆâ€œ8æ‹â†’4æ‹æ„Ÿè¦šâ€å‘ã‘ï¼‰</option>
            <option value="2">2.0ï¼ˆã‚‚ã£ã¨ã‚†ã£ãã‚Šï¼‰</option>
          </select>
          <div class="small">ã‚ãªãŸã®ã€Œ8æ‹ã˜ã‚ƒãªãã¦4æ‹ã€ãªã‚‰0.5ãŒåˆã„ã‚„ã™ã„</div>
        </div>

        <div>
          <label>è§£åƒåº¦</label>
          <select id="resolution">
            <option value="1280x720" selected>1280Ã—720 (16:9)</option>
            <option value="1080x1080">1080Ã—1080 (1:1)</option>
            <option value="1080x1920">1080Ã—1920 (9:16)</option>
            <option value="1920x1080">1920Ã—1080 (16:9)</option>
          </select>
        </div>

        <div>
          <label>FPS</label>
          <input id="fps" type="number" value="30" min="10" max="60" />
        </div>

        <div>
          <label>æ–‡å­—ã‚µã‚¤ã‚º</label>
          <input id="fontSize" type="number" value="54" min="18" max="120" />
        </div>

        <div>
          <label>ãƒ•ã‚§ãƒ¼ãƒ‰ï¼ˆç§’ï¼‰</label>
          <input id="fadeSec" type="number" value="0.20" step="0.05" min="0" max="1.5" />
        </div>

        <div>
          <label>å‹•ç”»åœæ­¢åŸºæº–</label>
          <select id="stopMode">
            <option value="race" selected>éŸ³æºçµ‚äº† or ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ï¼ˆæ—©ã„æ–¹ï¼‰</option>
            <option value="audio">éŸ³æºçµ‚äº†ã§æ­¢ã‚ã‚‹</option>
            <option value="timeline">ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³çµ‚ç«¯ã§æ­¢ã‚ã‚‹</option>
          </select>
        </div>
      </div>

      <div style="margin-top:10px" class="controls">
        <button id="applyTimeline">æ‹â†’ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³å†è¨ˆç®—</button>
        <button id="renderBtn">å‹•ç”»ç”Ÿæˆï¼ˆWebMï¼‰</button>
        <a id="downloadLink" style="display:none; margin-left:auto;" download="vtuber_1q1a.webm">ç”Ÿæˆå‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰</a>
      </div>
      <div id="status" class="small" style="margin-top:10px;"></div>
      <div class="small mono" id="debugLine" style="margin-top:6px; opacity:.75;"></div>
    </div>
  </div>

  <div class="row" style="margin-top:16px;">
    <div class="card" style="flex: 1 1 520px; min-width: 320px;">
      <h2>å›ç­”å…¥åŠ›ï¼ˆè³ªå•ï¼‹å›ç­”ãŒå­—å¹•ã«ãªã‚Šã¾ã™ï¼‰</h2>
      <div id="qaContainer"></div>
      <div class="small" style="margin-top:10px;">
        ï¼Šæ‹æ•°ï¼ˆbeatsï¼‰ã¯æ›²ã«åˆã‚ã›ã¦èª¿æ•´OKã€‚å€ç‡0.5ãªã‚‰ã€Œ8æ‹æŒ‡å®šï¼å®Ÿè³ª4æ‹æ„Ÿè¦šã€ã«ãªã‚Šã‚„ã™ã„ã§ã™ã€‚
      </div>
    </div>

    <div class="card" style="flex: 1 1 420px; min-width: 320px;">
      <h2>ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ï¼ˆå­—å¹•ç„¼ãè¾¼ã¿ï¼‰</h2>
      <canvas id="cv" width="1280" height="720"></canvas>

      <h2 style="margin-top:14px;">ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ï¼ˆç¢ºèªï¼‰</h2>
      <div class="small">start/end ã¯ã€Œæ‹â†’å†è¨ˆç®—ã€ã§æ›´æ–°ã€‚å‰å¥ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆæ‹ï¼‰ãŒ start ã«åæ˜ ã•ã‚Œã¾ã™ã€‚</div>
      <div style="max-height: 360px; overflow:auto; margin-top:8px;">
        <table>
          <thead>
            <tr>
              <th>#</th>
              <th>è³ªå•</th>
              <th>beats</th>
              <th>start</th>
              <th>end</th>
            </tr>
          </thead>
          <tbody id="timelineBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <script>
    (() => {
      // === 1) è³ªå•ã‚»ãƒƒãƒˆ ===
      // beats: ã“ã“ã¯ã€Œå­—å¹•1æšã‚ãŸã‚Šã®æ‹æ•°ã€ã€‚æ›²ã«åˆã‚ã›ã¦é©å½“ã«ã„ã˜ã‚Œã‚‹ã€‚
      const ITEMS = [
        { key: "intro1", q: "VTuberä¸€å•ä¸€ç­”è‡ªå·±ç´¹ä»‹", aDefault: "ãã‚Œã˜ã‚ƒã‚ã„ãã‚ˆã€€ã›ãƒ¼ã®ã£", beats: 16, fixed: true },

        { key: "name", q: "ãŠåå‰ã¯ï¼Ÿ", beats: 8 },
        { key: "call", q: "å‘¼ã³æ–¹ã¯ï¼Ÿ", beats: 8 },
        { key: "type", q: "ã‚ãªãŸã¯ä½•ç³»Vtuber?", beats: 8 },
        { key: "birthday", q: "èª•ç”Ÿæ—¥ã¯ï¼Ÿ", beats: 8 },
        { key: "age", q: "å¹´é½¢ã¯ï¼Ÿ", beats: 8 },
        { key: "gender", q: "æ€§åˆ¥ã¯ï¼Ÿ", beats: 8 },
        { key: "height", q: "èº«é•·ã¯ï¼Ÿ", beats: 8 },
        { key: "from", q: "å‡ºèº«ã¯ï¼Ÿ", beats: 8 },
        { key: "charm", q: "ãƒãƒ£ãƒ¼ãƒ ãƒã‚¤ãƒ³ãƒˆã¯ï¼Ÿ", beats: 8 },

        { key: "mimic", q: "çªç„¶ã§ã™ãŒã€ãƒ¢ãƒãƒãƒã©ã†ã", beats: 16 },

        { key: "place", q: "æ´»å‹•å ´æ‰€ã¯ï¼Ÿ", beats: 8 },
        { key: "hello", q: "ã¯ã˜ã‚ã®æŒ¨æ‹¶", beats: 12 },
        { key: "bye", q: "ãŠã‚ã‚Šã®æŒ¨æ‹¶", beats: 12 },
        { key: "oshi", q: "æ¨ã—ãƒãƒ¼ã‚¯ã¯ï¼Ÿ", beats: 8 },
        { key: "tag_stream", q: "é…ä¿¡ã‚¿ã‚°ã¯ï¼Ÿ", beats: 8 },
        { key: "tag_fanart", q: "ãƒ•ã‚¡ãƒ³ã‚¢ãƒ¼ãƒˆã¯ï¼Ÿ", beats: 8 },
        { key: "fanname", q: "ãƒ•ã‚¡ãƒ³ãƒãƒ¼ãƒ ã¯ï¼Ÿ", beats: 8 },
        { key: "color", q: "å¥½ããªè‰²ã¯ï¼Ÿ", beats: 8 },
        { key: "like", q: "å¥½ããªã“ã¨ã¯ï¼Ÿ", beats: 8 },
        { key: "skill", q: "å¾—æ„ãªã“ã¨ã¯ï¼Ÿ", beats: 8 },

        { key: "confess", q: "ã“ã“ã§ä¸€è¨€ã€Œæ„›ã®å‘Šç™½ã€", beats: 20 },

        { key: "food", q: "å¥½ããªé£Ÿã¹ç‰©ã¯ï¼Ÿ", beats: 8 },
        { key: "drink", q: "å¥½ããªé£²ã¿ç‰©ã¯ï¼Ÿ", beats: 8 },
        { key: "manga", q: "å¥½ããªæ¼«ç”»ã¯ï¼Ÿ", beats: 8 },
        { key: "anime", q: "å¥½ããªã‚¢ãƒ‹ãƒ¡ã¯ï¼Ÿ", beats: 8 },
        { key: "game", q: "å¥½ããªã‚²ãƒ¼ãƒ ã¯ï¼Ÿ", beats: 8 },
        { key: "music", q: "å¥½ããªéŸ³æ¥½ã¯ï¼Ÿ", beats: 8 },
        { key: "weak", q: "è‹¦æ‰‹ãªã“ã¨ã¯ï¼Ÿ", beats: 8 },
        { key: "respect", q: "å°Šæ•¬ã™ã‚‹ã®ã¯ï¼Ÿ", beats: 8 },
        { key: "dream", q: "å¶ãˆãŸã„å¤¢ã¯ï¼Ÿ", beats: 12 },

        { key: "last", q: "æœ€å¾Œã«ã¿ã‚“ãªã«ä¸€è¨€ã©ã†ãâ™ª", beats: 20 }
      ];

      // === 2) ã—ã‚‰ã„ã¯ã‹ã›ï¼šé©å½“å›ç­”ï¼ˆåˆæœŸå€¤ã¨ã—ã¦æ³¨å…¥ï¼‰ ===
      const DEFAULT_ANSWERS = {
        intro1: "ãã‚Œã˜ã‚ƒã‚ã„ãã‚ˆã€€ã›ãƒ¼ã®ã£",
        name: "ã—ã‚‰ã„ã¯ã‹ã›",
        call: "ã¯ã‹ã›ã€ã—ã‚‰ã„å…ˆç”Ÿã€å¥½ãã«å‘¼ã‚“ã§ã­",
        type: "ç”ŸæˆAIã¨ãƒ¡ã‚¿ãƒãƒ¼ã‚¹ã‚’ç ”ç©¶ã™ã‚‹å¤œè¡Œæ€§VTuberï¼ˆãŸã¶ã‚“ï¼‰",
        birthday: "3æœˆ13æ—¥",
        age: "æ°¸é ã®ç ”ç©¶è€…ï¼ˆå¹´é½¢ã¯å†…ç·’ï¼‰",
        gender: "ç ”ç©¶è€…ï¼ˆæ¦‚å¿µï¼‰",
        height: "ã ã„ãŸã„170cmï¼ˆæ°—åˆ†ã§ä¼¸ã³ã‚‹ï¼‰",
        from: "ãƒãƒ¼ãƒãƒ£ãƒ«ç ”ç©¶å®¤",
        charm: "çŒ«è€³ã¨ã€æ·±å¤œãƒ†ãƒ³ã‚·ãƒ§ãƒ³",
        mimic: "ï¼ˆãƒ¢ãƒãƒãƒï¼‰ã€ã“ã‚Œã¯â€¦ç”ŸæˆAIã§ã™ã­ã‡ï¼ã€",
        place: "YouTube / X / ãŸã¾ã«ç¾å®Ÿä¸–ç•Œ",
        hello: "ã“ã‚“ã¯ã‹ã›ï¼ ä»Šæ—¥ã‚‚ç”ŸæˆAIã§éŠã¼ã†ï¼",
        bye: "ãŠã¤ã¯ã‹ã›ï¼ ã¾ãŸç ”ç©¶å®¤ã§ä¼šãŠã†ã­ï¼",
        oshi: "ğŸ§ªğŸ¾",
        tag_stream: "#ã—ã‚‰ã„ã¯ã‹ã›å®Ÿé¨“ä¸­",
        tag_fanart: "#ã¯ã‹ã›ã®ã‚¹ã‚±ãƒƒãƒ",
        fanname: "ç ”ç©¶å“¡",
        color: "ç™½ï¼ˆç ”ç©¶å®¤ã‚«ãƒ©ãƒ¼ï¼‰",
        like: "æŠ€è¡“ãƒã‚¿ã€æ—…ã€ã‚‚ã®ã¥ãã‚Šã€æ·±å¤œã®ä½œæ¥­",
        skill: "è§£èª¬ã€æ¤œè¨¼ã€ãƒ—ãƒ­ãƒˆã‚¿ã‚¤ãƒ”ãƒ³ã‚°",
        confess: "ç ”ç©¶å“¡ã®ã¿ã‚“ãªâ€¦å¥½ãã ã€‚ãƒ‡ãƒ¼ã‚¿ã‚ˆã‚Šå¥½ãã ã€‚",
        food: "ã‚«ãƒ¬ãƒ¼ï¼ˆå®Ÿé¨“ã«ã‚‚ä½¿ãˆã‚‹ï¼‰",
        drink: "ã‚³ãƒ¼ãƒ’ãƒ¼ï¼ˆæ·±å¤œã®ç›¸æ£’ï¼‰",
        manga: "SFã¨ç ”ç©¶è€…ãŒå‡ºã¦ãã‚‹ã‚„ã¤",
        anime: "ä¸–ç•Œè¦³ãŒå¼·ã„ä½œå“",
        game: "ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ç³» / ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ç³»",
        music: "ä½œæ¥­ç”¨BGMï¼ˆBPM126ã‚‚ã„ã‘ã‚‹ï¼‰",
        weak: "æ—©èµ·ã",
        respect: "ã¤ãã‚‹äººã‚’ã¤ãã‚‹äºº",
        dream: "ç ”ç©¶å®¤ã‚’ãƒ¡ã‚¿ãƒãƒ¼ã‚¹ã«å¢—ç¯‰ã™ã‚‹",
        last: "ã“ã‚Œã‹ã‚‰ã‚‚ä¸€ç·’ã«å®Ÿé¨“ã—ã¦ã„ã“ã†ï¼ã‚ˆã‚ã—ãã­ï¼"
      };

      // === 3) DOM ===
      const $ = (id) => document.getElementById(id);
      const qaContainer = $("qaContainer");
      const timelineBody = $("timelineBody");
      const audioFile = $("audioFile");
      const bgFile = $("bgFile");
      const audioEl = $("audioEl");
      const bpmEl = $("bpm");
      const introOffsetBeatsEl = $("introOffsetBeats");
      const beatMultiplierEl = $("beatMultiplier");
      const resolutionEl = $("resolution");
      const fpsEl = $("fps");
      const fontSizeEl = $("fontSize");
      const fadeSecEl = $("fadeSec");
      const stopModeEl = $("stopMode");
      const applyTimelineBtn = $("applyTimeline");
      const renderBtn = $("renderBtn");
      const statusEl = $("status");
      const debugLine = $("debugLine");
      const downloadLink = $("downloadLink");
      const cv = $("cv");
      const ctx = cv.getContext("2d");

      // === state ===
      let bgImg = null;
      const answers = new Map();
      let timeline = []; // {i,key,q,a,beats,start,end}

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      function secPerBeat() {
        const bpm = clamp(parseFloat(bpmEl.value) || 126, 30, 300);
        const mult = parseFloat(beatMultiplierEl.value || "1"); // 1 or 0.5 etc.
        // 1 beat = quarter-note at BPM; multiplier scales it.
        return (60 / bpm) * mult;
      }

      function buildQAUI() {
        qaContainer.innerHTML = "";
        ITEMS.forEach((it, i) => {
          const wrap = document.createElement("div");
          wrap.style.marginBottom = "10px";
          wrap.className = "card";
          wrap.style.background = "rgba(127,127,127,.06)";
          wrap.style.borderRadius = "12px";
          wrap.style.padding = "10px";

          const title = document.createElement("div");
          title.style.fontWeight = "700";
          title.textContent = `${i + 1}. ${it.q}`;
          wrap.appendChild(title);

          const row = document.createElement("div");
          row.className = "grid";
          row.style.marginTop = "8px";

          const left = document.createElement("div");
          const right = document.createElement("div");

          const ansLabel = document.createElement("label");
          ansLabel.textContent = "å›ç­”ï¼ˆå­—å¹•ã®2è¡Œç›®ï¼‰";
          left.appendChild(ansLabel);

          const inp = document.createElement(it.fixed ? "input" : "textarea");
          if (it.fixed) inp.type = "text";
          const initial = (DEFAULT_ANSWERS[it.key] ?? it.aDefault ?? "");
          inp.value = initial;
          inp.placeholder = it.fixed ? "" : "ã“ã“ã«å›ç­”â€¦";
          inp.addEventListener("input", () => answers.set(it.key, inp.value.trim()));
          answers.set(it.key, inp.value.trim());
          left.appendChild(inp);

          const beatsLabel = document.createElement("label");
          beatsLabel.textContent = "beatsï¼ˆæ‹æ•°ï¼‰";
          right.appendChild(beatsLabel);

          const beatsInp = document.createElement("input");
          beatsInp.type = "number";
          beatsInp.min = "1";
          beatsInp.max = "128";
          beatsInp.value = it.beats;
          beatsInp.addEventListener("input", () => {
            it.beats = clamp(parseInt(beatsInp.value || "8", 10), 1, 128);
          });
          right.appendChild(beatsInp);

          row.appendChild(left);
          row.appendChild(right);
          wrap.appendChild(row);

          qaContainer.appendChild(wrap);
        });
      }

      function rebuildTimeline() {
        const spb = secPerBeat();
        const introBeats = clamp(parseInt(introOffsetBeatsEl.value || "0", 10), -9999, 9999);
        let t = introBeats * spb; // å‰å¥ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆæ‹ï¼‰ã‚’ç§’ã«å¤‰æ›ã—ã¦é©ç”¨

        timeline = ITEMS.map((it, idx) => {
          const beats = clamp(parseInt(it.beats || 8, 10), 1, 999);
          const dur = beats * spb;
          const a = answers.get(it.key) ?? it.aDefault ?? "";
          const obj = { i: idx, key: it.key, q: it.q, a, beats, start: t, end: t + dur };
          t += dur;
          return obj;
        });
        renderTimelineTable();

        const bpm = parseFloat(bpmEl.value || "126");
        const mult = parseFloat(beatMultiplierEl.value || "1");
        debugLine.textContent = `debug: BPM=${bpm} / beatMult=${mult} / secPerBeat=${spb.toFixed(4)} / introOffsetBeats=${introBeats} / timelineEnd=${(timeline[timeline.length - 1]?.end ?? 0).toFixed(2)}s`;
      }

      function renderTimelineTable() {
        timelineBody.innerHTML = "";
        timeline.forEach((it) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `
        <td>${it.i + 1}</td>
        <td>${escapeHtml(it.q)}</td>
        <td>${it.beats}</td>
        <td>${it.start.toFixed(2)}</td>
        <td>${it.end.toFixed(2)}</td>
      `;
          timelineBody.appendChild(tr);
        });
      }

      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, m => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#039;" }[m]));
      }

      function setStatus(msg) { statusEl.textContent = msg; }

      // === preview draw ===
      function drawFrame(tSec) {
        const W = cv.width, H = cv.height;

        // background: ç™½å›ºå®šï¼ˆç”»åƒãŒã‚ã‚Œã°ãã‚Œã‚’è¡¨ç¤ºï¼‰
        ctx.clearRect(0, 0, W, H);
        if (bgImg) {
          const r = Math.max(W / bgImg.width, H / bgImg.height);
          const dw = bgImg.width * r;
          const dh = bgImg.height * r;
          const dx = (W - dw) / 2;
          const dy = (H - dh) / 2;
          ctx.drawImage(bgImg, dx, dy, dw, dh);
        } else {
          ctx.fillStyle = "#00ff00";
          ctx.fillRect(0, 0, W, H);
        }

        const fade = clamp(parseFloat(fadeSecEl.value) || 0.2, 0, 3);

        // active item
        const active = timeline.find(it => tSec >= it.start && tSec < it.end);
        if (!active) return;

        const localT = tSec - active.start;
        const dur = active.end - active.start;

        let alpha = 1.0;
        if (fade > 0) {
          const fi = clamp(localT / fade, 0, 1);
          const fo = clamp((dur - localT) / fade, 0, 1);
          alpha = Math.min(fi, fo);
        }

        const pad = Math.round(Math.min(W, H) * 0.04);
        const panelH = Math.round(H * 0.28);
        const panelY = H - panelH - pad;

        // subtitle panel (é»’é€é)
        ctx.save();
        ctx.globalAlpha = 0.78 * alpha;
        ctx.fillStyle = "rgba(0,0,0,0.72)";
        roundRect(ctx, pad, panelY, W - pad * 2, panelH, 18);
        ctx.fill();
        ctx.restore();

        const fontSize = clamp(parseInt(fontSizeEl.value || "54", 10), 18, 200);
        const qFont = Math.round(fontSize * 0.95);
        const aFont = Math.round(fontSize * 1.05);

        // text
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.font = `700 ${qFont}px system-ui, -apple-system, "Segoe UI", "Noto Sans JP", sans-serif`;
        wrapText(ctx, active.q, W / 2, panelY + panelH * 0.38, W - pad * 3, qFont * 1.15);

        const ans = (active.a && active.a.length) ? active.a : "ï¼ˆæœªå…¥åŠ›ï¼‰";
        ctx.font = `800 ${aFont}px system-ui, -apple-system, "Segoe UI", "Noto Sans JP", sans-serif`;
        wrapText(ctx, ans, W / 2, panelY + panelH * 0.72, W - pad * 3, aFont * 1.2);

        ctx.restore();
      }

      function roundRect(ctx, x, y, w, h, r) {
        const rr = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + rr, y);
        ctx.arcTo(x + w, y, x + w, y + h, rr);
        ctx.arcTo(x + w, y + h, x, y + h, rr);
        ctx.arcTo(x, y + h, x, y, rr);
        ctx.arcTo(x, y, x + w, y, rr);
        ctx.closePath();
      }

      function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
        const s = String(text);
        // ã–ã£ãã‚Šåˆ†å‰²ï¼ˆç©ºç™½ãŒãªã„æ—¥æœ¬èªã«ã‚‚å¯¾å¿œï¼‰
        const words = s.includes(" ") ? s.split(/\s+/) : Array.from(s);

        let lines = [];
        let line = "";
        const tryPush = (candidate) => ctx.measureText(candidate).width <= maxWidth;

        const pushLine = () => { if (line.trim().length) lines.push(line.trim()); line = ""; };

        for (const w of words) {
          const test = (line ? line + (s.includes(" ") ? " " : "") : "") + w;
          if (tryPush(test)) line = test;
          else { pushLine(); line = w; }
        }
        pushLine();

        if (lines.length > 3) {
          lines = lines.slice(0, 3);
          const last = lines[2];
          lines[2] = last.length > 18 ? last.slice(0, 18) + "â€¦" : last + "â€¦";
        }

        const totalH = lines.length * lineHeight;
        let yy = y - totalH / 2 + lineHeight / 2;
        for (const ln of lines) {
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.55)";
          ctx.fillText(ln, x + 2, yy + 2);
          ctx.restore();
          ctx.fillStyle = "white";
          ctx.fillText(ln, x, yy);
          yy += lineHeight;
        }
      }

      // === media handling ===
      audioFile.addEventListener("change", () => {
        const f = audioFile.files?.[0];
        if (!f) return;
        const url = URL.createObjectURL(f);
        audioEl.src = url;
        audioEl.load();
        setStatus(`BGMèª­ã¿è¾¼ã¿: ${f.name}`);
      });

      bgFile.addEventListener("change", async () => {
        const f = bgFile.files?.[0];
        if (!f) { bgImg = null; return; }
        const url = URL.createObjectURL(f);
        const img = new Image();
        img.onload = () => { bgImg = img; URL.revokeObjectURL(url); };
        img.src = url;
      });

      resolutionEl.addEventListener("change", () => {
        const [w, h] = resolutionEl.value.split("x").map(n => parseInt(n, 10));
        cv.width = w; cv.height = h;
        drawFrame(0);
      });

      applyTimelineBtn.addEventListener("click", () => {
        rebuildTimeline();
        drawFrame(0);
        setStatus("ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚’å†è¨ˆç®—ã—ã¾ã—ãŸã€‚");
      });

      // util: wait audio metadata
      function waitLoadedMetadata(mediaEl) {
        if (isFinite(mediaEl.duration) && mediaEl.duration > 0) return Promise.resolve();
        return new Promise((resolve, reject) => {
          const onOk = () => { cleanup(); resolve(); };
          const onErr = () => { cleanup(); reject(new Error("audio metadata load failed")); };
          const cleanup = () => {
            mediaEl.removeEventListener("loadedmetadata", onOk);
            mediaEl.removeEventListener("durationchange", onOk);
            mediaEl.removeEventListener("error", onErr);
          };
          mediaEl.addEventListener("loadedmetadata", onOk, { once: true });
          mediaEl.addEventListener("durationchange", onOk, { once: true });
          mediaEl.addEventListener("error", onErr, { once: true });
          mediaEl.load();
        });
      }

      function waitSeconds(s) {
        return new Promise(res => setTimeout(res, Math.max(0, s) * 1000));
      }

      function stopRecorder(rec, timeoutMs = 8000) {
        return new Promise((resolve, reject) => {
          const timer = setTimeout(() => {
            try { rec.requestData?.(); } catch { }
            reject(new Error("MediaRecorder stop timeout"));
          }, timeoutMs);

          rec.addEventListener("stop", () => {
            clearTimeout(timer);
            resolve();
          }, { once: true });

          try { rec.requestData?.(); } catch { }
          rec.stop();
        });
      }

      // === render video ===
      async function renderVideo() {
        const f = audioFile.files?.[0];
        if (!f) { alert("BGMãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸ã‚“ã§ãã ã•ã„"); return; }

        rebuildTimeline();

        // ensure duration is available (prevents Infinity hang)
        await waitLoadedMetadata(audioEl);

        const timelineEnd = timeline[timeline.length - 1]?.end ?? 0;
        const audioDur = (isFinite(audioEl.duration) && audioEl.duration > 0) ? audioEl.duration : timelineEnd;
        const stopMode = stopModeEl.value;

        // Setup AudioContext mix -> MediaStreamDestination
        const ac = new (window.AudioContext || window.webkitAudioContext)();
        const src = ac.createMediaElementSource(audioEl);
        const gain = ac.createGain();
        gain.gain.value = 1.0;
        const dest = ac.createMediaStreamDestination();
        src.connect(gain).connect(dest);
        gain.connect(ac.destination); // monitor on speakers

        const fps = clamp(parseInt(fpsEl.value || "30", 10), 10, 60);
        const stream = cv.captureStream(fps);
        const mixed = new MediaStream([stream.getVideoTracks()[0], dest.stream.getAudioTracks()[0]]);

        const candidates = [
          'video/webm;codecs=vp9,opus',
          'video/webm;codecs=vp8,opus',
          'video/webm;codecs=vp9',
          'video/webm'
        ];
        let mimeType = "";
        for (const c of candidates) {
          if (MediaRecorder.isTypeSupported(c)) { mimeType = c; break; }
        }
        if (!mimeType) mimeType = "video/webm";

        const rec = new MediaRecorder(mixed, { mimeType, videoBitsPerSecond: 6_000_000 });
        const chunks = [];
        rec.ondataavailable = (e) => { if (e.data && e.data.size) chunks.push(e.data); };

        rec.addEventListener("start", () => console.log("[rec] start"));
        rec.addEventListener("dataavailable", (e) => console.log("[rec] chunk", e.data?.size));
        rec.addEventListener("stop", () => console.log("[rec] stop"));

        const startedAt = performance.now();
        let rafId = 0;
        let stopped = false;

        function tick() {
          const t = (performance.now() - startedAt) / 1000;
          drawFrame(t);
          if (!stopped) rafId = requestAnimationFrame(tick);
        }

        console.log("[debug] audioDur=", audioDur, "timelineEnd=", timelineEnd, "stopMode=", stopMode);
        setStatus(`éŒ²ç”»ä¸­â€¦ mimeType=${mimeType}`);
        downloadLink.style.display = "none";
        downloadLink.href = "";

        rec.start(200);
        await ac.resume();

        audioEl.currentTime = 0;
        await audioEl.play();

        tick();

        // Decide stopping condition (prevents "å€ä»¥ä¸Šã«ä¼¸ã³ã‚‹" äº‹æ•…)
        const tail = 0.25;

        const waitAudioEnded = new Promise(res => audioEl.addEventListener("ended", res, { once: true }));
        const waitTimeline = waitSeconds(Math.max(0, timelineEnd + tail));

        if (stopMode === "audio") {
          await waitAudioEnded;
        } else if (stopMode === "timeline") {
          await waitTimeline;
        } else {
          // race (earlier)
          await Promise.race([waitAudioEnded, waitTimeline]);
        }

        stopped = true;
        cancelAnimationFrame(rafId);
        audioEl.pause();

        await stopRecorder(rec, 10000);
        await ac.close().catch(() => { });

        const blob = new Blob(chunks, { type: "video/webm" });
        const url = URL.createObjectURL(blob);
        downloadLink.href = url;
        downloadLink.style.display = "inline-block";
        setStatus(`å®Œäº†ï¼å‹•ç”»ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã§ãã¾ã™ï¼ˆéŸ³æº ${audioDur.toFixed(1)}s / timeline ${timelineEnd.toFixed(1)}sï¼‰`);
      }

      renderBtn.addEventListener("click", async () => {
        renderBtn.disabled = true;
        try {
          await renderVideo();
        } catch (e) {
          console.error(e);
          alert("ç”Ÿæˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\n" + (e?.message || e));
          setStatus("ã‚¨ãƒ©ãƒ¼ï¼š" + (e?.message || e));
        } finally {
          renderBtn.disabled = false;
        }
      });

      // init
      buildQAUI();
      rebuildTimeline();
      drawFrame(0);
    })();
  </script>
</body>

</html>